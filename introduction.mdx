---
title: Introduction
---

Typesync is an open-source schema management tool that simplifies managing [Firestore](https://cloud.google.com/firestore) databases. Typesync allows you to maintain a single source of truth for your Firestore architecture in a special _schema_. With this schema in place, you can seamlessly auto-generate type definitions for multiple platforms like TypeScript, Python, Swift, and more using the CLI tool.

Typesync keeps your database and application code consistent and up-to-date at all times. In addition to type definitions, it lets you generate other useful things like Security Rules, boilerplate code for Cloud Functions, and documentation for your data models.

<Frame
  type="glass"
  caption="Single source of truth for your Firestore architecture"
>
  <img src="/images/architecture.png" />
</Frame>

## Typesync in 30 seconds

You define your Firestore schema in a collection of YAML/JSON files. The Typesync CLI reads these files and produces ready-to-use Firestore model definitions for all the languages and platforms you work with.

In the example below, we define our models in `models.yml`.

```yaml models.yml
# yaml-language-server: $schema=https://schema.typesync.org/v0.4.json

UserRole:
  model: alias
  docs: Represents a user's role within a project.
  type:
    type: enum
    members:
      - label: Owner
        value: owner
      - label: Admin
        value: admin
      - label: Member
        value: member

User:
  model: document
  docs: Represents a user that belongs to a project.
  type:
    type: object
    fields:
      username:
        type: string
        docs: A string that uniquely identifies the user within a project.
      role:
        type: UserRole
      created_at:
        type: timestamp
```

We then run the following commands to generate types for 3 different platforms:

<CodeGroup>

```bash TS (frontend)
typesync generate-ts --platform ts:firebase:10 --definition models.yml # ... other options
```

```bash TS (backend)
typesync generate-ts --platform ts:firebase-admin:11 --definition models.yml # ... other options
```

```bash Python
typesync generate-py --platform py:firebase-admin:6 --definition models.yml # ... other options
```

</CodeGroup>

Typesync generates the following files:

<CodeGroup>

```ts models.ts (frontend)
import type * as firestore from "firebase/firestore";

/**
 * Represents a user's role within a project.
 */
export type UserRole = "owner" | "admin" | "member";

/**
 * Represents a user that belongs to a project.
 */
export interface User {
  /**
   * A string that uniquely identifies the user within a project.
   */
  username: string;
  role: UserRole;
  created_at: firestore.Timestamp;
}
```

```ts models.ts (backend)
import { firestore } from "firebase-admin";

/**
 * Represents a user's role within a project.
 */
export type UserRole = "owner" | "admin" | "member";

/**
 * Represents a user that belongs to a project.
 */
export interface User {
  /**
   * A string that uniquely identifies the user within a project.
   */
  username: string;
  role: UserRole;
  created_at: firestore.Timestamp;
}
```

```python models.py
from __future__ import annotations

import enum
import pydantic

# [static declarations redacted for brevity]

class UserRole(enum.Enum):
    """Represents a user's role within a project."""
    Owner = "owner"
    Admin = "admin"
    Member = "member"

class User(TypesyncModel):
    """Represents a user that belongs to a project."""
    username: str
    """A string that uniquely identifies the user within a project."""
    role: UserRole
    created_at: datetime.datetime

    class Config:
        use_enum_values = True

    def __setattr__(self, name: str, value: typing.Any) -> None:
        super().__setattr__(name, value)
```

</CodeGroup>

Once we have the generated models, we can import and use them in our application code.

<CodeGroup>

```ts app.ts (frontend)
import {
  getFirestore,
  doc,
  getDoc,
  collection,
  type CollectionReference,
} from "firebase/firestore";
import type { User } from "./models";

const firestore = getFirestore();
const usersColRef = collection(firestore, "users") as CollectionReference<User>;
const userDocRef = doc(usersColRef, "adam");
const userSnap = await getDoc(userDocRef);
const user = userSnap.data(); // is a User object (or undefined)
```

```ts app.ts (backend)
import { firestore } from "firebase-admin";
import type { User } from "./models";

const usersColRef = firestore().collection(
  "users"
) as firestore.CollectionReference<User>;
const userSnap = await usersColRef.doc("adam").get();
const user = userSnap.data(); // is a User object (or undefined)
```

```python app.py
import firebase_admin
from datetime import datetime
from models import User, UserRole

def initialize_firestore():
    service_account_path = './service-account.json'
    cred = credentials.Certificate(service_account_path)
    firebase_admin.initialize_app(cred)
    return firestore.client()

db = initialize_firestore()

user = User(
    username="johnappleseed",
    role=UserRole.Owner,
    created_at=datetime.now()
)
doc_ref = db.collection('users').document("adam")
doc_ref.set(user.model_dump())
```

</CodeGroup>

## Design Goals

Typesync is built on three core principles that guide its design and functionality.

### 1. Predictability

Typesync values straightforward operation over complexity. It doesn't try to outsmart you by making implicit assumptions. There are no "gotchas", no hidden configurations. When faced with bad input, Typesync prefers to issue an error rather than make assumptions and try to make the most of the situation.

Our philosophy is straightforward: developer tools should consistently perform as expected, without any surprising behaviorâ€”even if such behavior might be seen as beneficial to some. Essentially, tools should remain "dumb" in their operations, even while performing complex tasks.

The predictability that this behavior produces means that you always know what to expect from Typesync as it does only what it promises to do. Nothing more, nothing less.

### 2. Ejectability

Flexibility is central to Typesync's design. It's developed to be non-intrusive, with no lock-in effects. You can easily integrate Typesync into your projects without major changes to your codebase.

Typesync _is not_ a library that tightly attaches itself to your code. You can eject at any time by simply copy-pasting the generated output into your source code without having to refactor your code. Moving away from Typesync is as simple as integrating it.

### 3. Configurability

Everything that can be reasonably expected to be configurable is made explicitly configurable by Typesync. Whether it's defining how your schema is structured or customizing the output for different programming languages, Typesync provides you with the flexibility to make those decisions.

Typesync is designed to be as customizable as possible, allowing you to tailor the tool to your project's requirements.
